<!DOCTYPE html>
<html lang="ko">
<head>
    <title>Vue3 + PrimeVue Sample</title>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=0.9, maximum-scale=1.8, minimum-scale=0.9, user-scalable=yes">

    <link href="css/primeicons.css" rel="stylesheet"/>
    <link href="/css/swiper-bundle.min.css" rel="stylesheet"/>
    <link href="css/custom.css" rel="stylesheet"/>
    <link href="css/overlayscrollbars.min.css" rel="stylesheet"/>

    <script src="js/vue.global.js"></script>
    <script src="js/primevue.min.js"></script>
    <script src="js/aura.js"></script>
    <script src="js/tailwindcss.js"></script>
    <script src="/js/swiper-bundle.min.js"></script>
    <script src="/js/overlayscrollbars.browser.es6.min.js"></script>

</head>
<body class="bg-gray-100">
<div id="app">
    <overlay-scrollbars style="max-height: 100vh;">
        <div class="mx-auto py-6 space-y-6" style="max-width: 1035px;">
            <h1 class="text-2xl font-bold text-center">Vue3 + PrimeVue Sample <span class="text-cyan-600">(Tabs, Swiper, Drawer)</span></h1>

            <p-toolbar class="justify-between">
                <template #center>
                    <div class="flex flex-wrap gap-2">
                        <a href="sample1.html">
                            <p-button label="Form" size="small" outlined/>
                        </a>
                        <a href="sample2.html">
                            <p-button label="Tabs/Swiper/Drawer" size="small" outlined/>
                        </a>
                        <a href="sample3.html">
                            <p-button label="DataTable" size="small" outlined/>
                        </a>
                        <a href="sample4.html">
                            <p-button label="Tree/PickList" size="small" outlined/>
                        </a>
                        <a href="sample5.html">
                            <p-button label="Button/Speed Dial" size="small" outlined/>
                        </a>
                        <a href="sample6.html">
                            <p-button label="Tag/Spinner/Toast" size="small" outlined/>
                        </a>
                        <a href="sample7.html">
                            <p-button label="Overlays" size="small" outlined/>
                        </a>
                    </div>
                </template>
            </p-toolbar>

            <section id="content" class="bg-white rounded shadow relative" style="padding: 15px">
                <p-drawer v-model:visible="drawerVisible" header="전체메뉴" class="!w-[510px]"
                          position="left"
                          :pt="{
                              content: { style: { overflow: 'hidden', height: '100%' } }
                          }">
                    <overlay-scrollbars style="max-height: 100%; height: 100%">
                        <div style="padding: 12px">
                            <p class="text-sm text-gray-600 mb-2">원하는 메뉴를 선택하면 탭이 생성됩니다.</p>
                            <ul class="space-y-1">
                                <li v-for="m in menuItems" :key="m.key">
                                    <button type="button" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100 flex items-center gap-2"
                                            @click="addOrActivateTab(m)">
                                        <i class="pi pi-angle-right text-gray-500"></i>
                                        <span>{{ m.label }}</span>
                                    </button>
                                </li>
                            </ul>
                        </div>
                    </overlay-scrollbars>
                </p-drawer>
                <p-tabs class="menu-tab-list" v-model:value="selected">
                    <!-- 탭바 (p-tab-list 자체에 ref를 달아 $el로 DOM 접근) -->
                    <p-tab-list ref="tabListComp">
                        <div class="tab-header">
                            <div class="tab-header-actions">
                                <p-button icon="pi pi-bars" severity="secondary" variant="text" size="small" raised rounded aria-label="전체메뉴" @click="drawerVisible = true"></p-button>
                                <p-button icon="pi pi-home" severity="secondary" variant="text" size="small" raised rounded aria-label="홈" as="a" href="http://localhost:63342/vue3-primeVue-sample/sample2.html"></p-button>
                            </div>
                            <div class="tab-header-body">
                                <button ref="prevBtnRef" type="button" class="tabs-nav-btn tabs-prev" aria-label="이전">
                                    <i class="pi pi-chevron-left"></i>
                                </button>
                                <swiper class="tabs-swiper" :options="swiperOptions" @ready="onSwiperReady">
                                    <template #default>
                                        <swiper-slide v-for="(t,i) in tabs" :key="t.key" class="tab-slide">
                                            <div class="tab-item-wrap">
                                                <!-- PassThrough(:pt)로 data-index를 부여 (필요 시 유지) -->
                                                <p-tab :value="i" :pt="getTabPT(i)">
                                                    <span class="tab-text">{{ t.label }}</span>
                                                    <button
                                                            type="button"
                                                            class="tab-close"
                                                            aria-label="닫기"
                                                            @click.stop="removeTab(t.key)"
                                                    >
                                                        <i class="pi pi-times"></i>
                                                    </button>
                                                </p-tab>
                                            </div>
                                        </swiper-slide>
                                    </template>
                                </swiper>
                                <button ref="nextBtnRef" type="button" class="tabs-nav-btn tabs-next" aria-label="다음">
                                    <i class="pi pi-chevron-right"></i>
                                </button>
                            </div>
                        </div>
                    </p-tab-list>

                    <!-- 탭 패널 -->
                    <p-tab-panels>
                        <p-tab-panel v-for="(t,i) in tabs" :key="t.key" :value="i">
                            <div class="text-gray-700" :class="{'opacity-40 pointer-events-none select-none': isLoading(t.key) }">
                                {{ t.desc }}
                            </div>
                            <div v-if="isLoading(t.key)">
                                로딩 중... (약 {{ remainingSeconds(t.key) }}초 후 완료)
                            </div>
                            <div v-if="isLoading(t.key)" class="absolute inset-0 flex items-center justify-center bg-black/10" style="border-radius: 5px 5px 10px 10px;">
                                <div class="flex items-center">
                                    <p-progress-spinner style="width:40px;height:40px" stroke-width="8" fill="transparent" animationDuration=".5s" aria-label="loading"/>
                                </div>
                            </div>
                        </p-tab-panel>
                    </p-tab-panels>
                </p-tabs>
            </section>
        </div>
    </overlay-scrollbars>
</div>

<script>
    const {createApp, ref, onMounted, onBeforeUnmount, h, watch, nextTick, computed} = Vue;

    /* Swiper 래퍼: 내부 DOM refs를 ready 이벤트로 부모에 전달 */
    const SwiperComponent = {
        name: 'swiper',
        emits: ['ready'],
        props: {options: {type: Object, default: () => ({})}},
        setup(props, {slots, emit}) {
            const rootEl = ref(null);
            const wrapperEl = ref(null);
            let instance = null;

            onMounted(() => {
                instance = new Swiper(rootEl.value, props.options || {});
                emit('ready', {rootEl: rootEl.value, wrapperEl: wrapperEl.value, instance});
            });
            onBeforeUnmount(() => {
                if (instance && typeof instance.destroy === 'function') {
                    instance.destroy(true, true);
                }
            });

            return () =>
                h('div', {ref: rootEl, class: 'swiper'}, [
                    h('div', {ref: wrapperEl, class: 'swiper-wrapper'}, slots.default ? slots.default() : [])
                ]);
        }
    };

    const SwiperSlideComponent = {
        name: 'swiper-slide',
        setup(_, {slots}) {
            return () => h('div', {class: 'swiper-slide'}, slots.default ? slots.default() : []);
        }
    };

    /* ──────────────── App ──────────────── */
    const app = createApp({
        setup() {
            const drawerVisible = ref(false);
            const tabs = ref([]);
            const selected = ref(0);
            // 로딩 상태: 탭 key별 최초 1회만 로딩 표시
            const loadingByKey = ref({}); // { [key]: boolean }
            const loadedOnceByKey = ref({}); // { [key]: boolean }
            const remainingMsByKey = ref({}); // { [key]: number } - 남은 시간(ms)
            const timersByKey = new Map(); // Map<key, Timeout>
            const intervalsByKey = new Map(); // Map<key, Interval> - 카운트다운 업데이트

            // 메뉴 목록: Drawer에서 선택 시 탭 생성용
            const menuItems = [
                {key: 't1', label: '초과근무신청', desc: '초과근무신청 내용입니다.'},
                {key: 't2', label: '업소/시설', desc: '업소/시설 내용입니다.'},
                {key: 't3', label: '검사계획관리', desc: '검사계획관리 내용입니다.'},
                {key: 't4', label: '검사결과등록', desc: '검사결과등록 내용입니다.'},
                {key: 't5', label: '시설검사결과등록', desc: '시설검사결과등록 내용입니다.'},
                {key: 't6', label: '가상계좌발송', desc: '가상계좌발송 내용입니다.'},
            ];

            // Drawer 메뉴 선택 시 탭 추가
            const addOrActivateTab = async (item) => {
                if (!item) return;
                const existsIdx = tabs.value.findIndex(t => t.key === item.key);
                if (existsIdx !== -1) {
                    selected.value = existsIdx;
                } else {
                    // 새 탭을 앞쪽에 추가(prepend)하고 생성 애니메이션 트리거
                    tabs.value.unshift({ key: item.key, label: item.label, desc: item.desc });
                    selected.value = 0;
                    // 선택된 즉시 최초 1회 로딩 시작 (최초 생성 시점 기준으로만 진행)
                    startOnceLoadingForKey(item.key);
                    await nextTick();
                    // Swiper 업데이트 및 첫 번째 슬라이드로 이동
                    if (swiperInstance.value?.update) {
                        swiperInstance.value.update();
                        if (typeof swiperInstance.value.slideTo === 'function') {
                            swiperInstance.value.slideTo(0);
                        }
                    }
                    // 생성 애니메이션: wrapper에 잠깐 is-prepending 클래스 부여
                    const wrapper = swiperWrapperEl.value;
                    if (wrapper) {
                        wrapper.classList.add('is-prepending');
                        if (wrapper._prependTimer) clearTimeout(wrapper._prependTimer);
                        wrapper._prependTimer = setTimeout(() => {
                            wrapper.classList.remove('is-prepending');
                            wrapper._prependTimer = null;
                        }, 260);
                    }
                }
                // 메뉴는 닫기
                drawerVisible.value = false;
            };

            // p-tab-list 컴포넌트 ref → DOM은 $el
            const tabListComp = ref(null);

            // Swiper 및 네비 버튼 refs
            const swiperWrapperEl = ref(null);
            const swiperInstance = ref(null);
            const prevBtnRef = ref(null);
            const nextBtnRef = ref(null);

            // Swiper 옵션
            const swiperOptions = {
                slidesPerView: 5,
                spaceBetween: 5,
                watchOverflow: false,
                navigation: {
                    nextEl: '.menu-tab-list .tabs-next',
                    prevEl: '.menu-tab-list .tabs-prev'
                }
            };

            // PT 헬퍼: 각 탭 루트/액션에 data-index를 부여
            const getTabPT = (i) => ({
                root: {'data-index': i},
                action: {'data-index': i}
            });

            // Swiper ready 콜백 (인스턴스 저장)
            const onSwiperReady = ({wrapperEl, instance}) => {
                swiperWrapperEl.value = wrapperEl;
                swiperInstance.value = instance;
            };

            // 로딩 트리거: 탭별 최초 1회만 2~10초 랜덤 로딩
            const startOnceLoadingForKey = (key) => {
                if (!key) return;
                if (loadedOnceByKey.value[key]) return; // 이미 최초 로딩 완료
                // 기존 타이머/인터벌 제거
                const prev = timersByKey.get(key);
                if (prev) clearTimeout(prev);
                const prevInt = intervalsByKey.get(key);
                if (prevInt) clearInterval(prevInt);
                // 시작
                loadingByKey.value = {...loadingByKey.value, [key]: true};
                const duration = 2000 + Math.floor(Math.random() * 9000); // 2~10초
                remainingMsByKey.value = {...remainingMsByKey.value, [key]: duration};
                const startedAt = Date.now();
                const tm = setTimeout(() => {
                    loadedOnceByKey.value = {...loadedOnceByKey.value, [key]: true};
                    loadingByKey.value = {...loadingByKey.value, [key]: false};
                    remainingMsByKey.value = {...remainingMsByKey.value, [key]: 0};
                    timersByKey.delete(key);
                    const intv = intervalsByKey.get(key);
                    if (intv) clearInterval(intv);
                    intervalsByKey.delete(key);
                }, duration);
                timersByKey.set(key, tm);
                // 카운트다운 인터벌 (100ms)
                const intv = setInterval(() => {
                    const elapsed = Date.now() - startedAt;
                    const remain = Math.max(0, duration - elapsed);
                    remainingMsByKey.value = {...remainingMsByKey.value, [key]: remain};
                    if (remain <= 0) {
                        clearInterval(intv);
                        intervalsByKey.delete(key);
                    }
                }, 100);
                intervalsByKey.set(key, intv);
            };
            const isLoading = (key) => !!loadingByKey.value[key];
            const remainingSeconds = (key) => {
                const ms = remainingMsByKey.value[key] ?? 0;
                // 최소 1초로 표시하여 사용자 인지성 향상 (0일 때는 오버레이가 이미 사라짐)
                return Math.max(1, Math.ceil(ms / 1000));
            };

            // 활성 탭 변경 감지 → 아직 최초 로딩 전이면 한 번만 로딩 시작
            watch(selected, (i) => {
                const key = typeof i === 'number' ? tabs.value[i]?.key : undefined;
                if (key && !loadedOnceByKey.value[key]) startOnceLoadingForKey(key);
            });

            // 새 탭이 추가될 때: 선택된 탭이 로딩 전이면 한 번만 로딩 처리
            watch(tabs, (arr) => {
                const idx = selected.value ?? 0;
                const key = arr[idx]?.key;
                if (typeof idx === 'number' && key && !loadedOnceByKey.value[key]) {
                    startOnceLoadingForKey(key);
                }
            });

            onBeforeUnmount(() => {
                timersByKey.forEach((tm) => clearTimeout(tm));
                timersByKey.clear();
                intervalsByKey.forEach((iv) => clearInterval(iv));
                intervalsByKey.clear();
            });

            // 탭 제거 로직
            const removeTab = (key) => {
                if (!key) return;
                const idx = tabs.value.findIndex(t => t.key === key);
                if (idx === -1) return;
                // 이미 leaving 처리중이면 중복 방지
                const wrapper = swiperWrapperEl.value;
                try {
                    // 해당 슬라이드의 DOM을 찾아 is-leaving 클래스 추가
                    const slides = wrapper?.querySelectorAll('.swiper-slide');
                    const slideEl = slides?.[idx];
                    const contentEl = slideEl?.querySelector('.tab-item-wrap');
                    if (contentEl && !contentEl.classList.contains('is-leaving')) {
                        contentEl.classList.add('is-leaving');
                        // 패널도 함께 퇴장 애니메이션
                        const panelRoot = document.querySelectorAll('.p-tabpanels .p-tabpanel')[idx];
                        if (panelRoot) panelRoot.classList.add('is-leaving');
                        const handleEnd = () => {
                            contentEl.removeEventListener('animationend', handleEnd);
                            // 실제 데이터에서 제거
                            doRemove(idx, key);
                        };
                        contentEl.addEventListener('animationend', handleEnd);
                        // 안전망: 애니메이션 이벤트 누락 대비
                        setTimeout(() => {
                            if (tabs.value.findIndex(t => t.key === key) !== -1) {
                                doRemove(idx, key);
                            }
                        }, 400);
                    } else {
                        // DOM을 못 찾으면 즉시 제거
                        doRemove(idx, key);
                    }
                } catch (e) {
                    doRemove(idx, key);
                }
            };

            const doRemove = async (idx, key) => {
                // 패널 퇴장 클래스 제거 (혹시 남아있으면)
                const panelRoot = document.querySelectorAll('.p-tabpanels .p-tabpanel')[idx];
                panelRoot?.classList.remove('is-leaving');

                // 선택 상태 갱신
                let nextSelected = selected.value;
                if (idx === selected.value) {
                    // 활성 탭 제거 → 오른쪽이 있으면 그쪽, 없으면 왼쪽
                    if (idx < tabs.value.length - 1) nextSelected = idx; else nextSelected = Math.max(0, idx - 1);
                } else if (idx < selected.value) {
                    // 앞쪽 탭 제거 → 선택 인덱스 한 칸 당김
                    nextSelected = Math.max(0, selected.value - 1);
                }

                // 로딩 타이머/인터벌 정리
                const prev = timersByKey.get(key);
                if (prev) clearTimeout(prev);
                timersByKey.delete(key);
                const prevInt = intervalsByKey.get(key);
                if (prevInt) clearInterval(prevInt);
                intervalsByKey.delete(key);

                // 데이터에서 제거
                const newTabs = tabs.value.slice();
                newTabs.splice(idx, 1);
                tabs.value = newTabs;
                selected.value = Math.min(nextSelected, Math.max(0, tabs.value.length - 1));

                await nextTick();
                if (swiperInstance.value?.update) {
                    swiperInstance.value.update();
                    // 현재 선택된 탭이 보이도록 이동
                    const target = selected.value ?? 0;
                    if (typeof swiperInstance.value.slideTo === 'function') {
                        swiperInstance.value.slideTo(target);
                    }
                }
            };

            return {
                tabs, selected,
                swiperOptions,
                tabListComp,
                prevBtnRef, nextBtnRef,
                onSwiperReady,
                getTabPT,
                swiperInstance,
                isLoading,
                remainingSeconds,
                removeTab,
                drawerVisible,
                // Drawer 메뉴 연동
                menuItems,
                addOrActivateTab
            };
        },
    });

    // PrimeVue 등록
    app.use(PrimeVue.Config, {theme: {preset: PrimeUIX.Themes.Aura}});
    const {Tabs, TabList, Tab, TabPanels, TabPanel, Toolbar, Button, ProgressSpinner, Drawer} = PrimeVue;
    app.component('p-tabs', Tabs);
    app.component('p-tab-list', TabList);
    app.component('p-tab', Tab);
    app.component('p-tab-panels', TabPanels);
    app.component('p-tab-panel', TabPanel);
    app.component('p-toolbar', Toolbar);
    app.component('p-button', Button);
    app.component('p-progress-spinner', ProgressSpinner);
    app.component('p-drawer', Drawer);

    // Swiper 컴포넌트 등록
    app.component('swiper', SwiperComponent);
    app.component('swiper-slide', SwiperSlideComponent);

    app.component('overlay-scrollbars', {
        props: ['style', 'class'],
        mounted() {
            window.OverlayScrollbarsGlobal.OverlayScrollbars(this.$el, {scrollbars: {autoHide: 'scroll'}});
        },
        render() {
            return Vue.h('div', {style: this.style, class: this.class}, this.$slots.default());
        }
    });

    app.mount('#app');
</script>
</body>
</html>
